"use strict";function WEBRTC(send,stunURLs=[]){let onState=null,calls={},stateHandler=(conn,state)=>{onState&&"function"==typeof onState&&onState(conn,state)};const config={iceServers:[{urls:stunURLs}]},ChannelOpen=(e,pc,id)=>{stateHandler(calls[id],{type:"channel",channel:e.target.label,message:"Data channel open"})},ChannelAdded=(e,pc,id)=>{let label=e.channel.label;return calls[id].channels[label]=e.channel,calls[id].channels[label].onopen=(e=>{ChannelOpen(e,pc,id)}),calls[id].channels[label]},remoteTrackAdded=(e,pc,id)=>{calls[id].remoteTracks||(calls[id].remoteTracks=[]),calls[id].remoteTracks.push(e.track),stateHandler(calls[id],{type:"remoteTrack",track:e.track,message:"Remote media track added"})},localTrackAdded=(stream,pc,id)=>{for(let track of stream.getTracks())pc.addTrack(track),calls[id].localTracks.push(track),stateHandler(calls[id],{type:"localTrack",track:track,message:"Local media track added"})},Disconnected=(e,pc,id)=>{stateHandler(calls[id],{type:"disconnected"})};return{calls:calls,call:function(to,stream=null){return new Promise(async(resolve,reject)=>{let id=crypto.getRandomValues(new Uint8Array(32)).join("").toString().slice(0,16),pc=new RTCPeerConnection(config);calls[id]={id:id,pc:pc,channels:{},localTracks:[],remoteTracks:[]},calls[id].channels.chat=pc.createDataChannel("chat"),calls[id].channels.chat.onopen=(e=>{ChannelOpen(e,pc,id)}),pc.onclose=(e=>{Disconnected(e,pc,id)}),stream&&localTrackAdded(stream,pc,id),pc.ondatachannel=(e=>{ChannelAdded(e,pc,id)}),pc.ontrack=(e=>{remoteTrackAdded(e,pc,id)}),pc.createOffer().then(desc=>{pc.setLocalDescription(desc),send({id:id,to:to.toString(),type:"call",stream:!!stream,call:{desc:pc.localDescription}}),pc.onicecandidate=(e=>{e.candidate&&send({id:id,to:to.toString(),type:"call",call:{candidate:e.candidate}})}),resolve(calls[id])})})},answer:function(call,stream){return new Promise(async(resolve,reject)=>{if(!call&&!call.id&&"call"===!call.type)return null;if(calls[call.id]&&call.call&&call.call.candidate)return await calls[call.id].pc.addIceCandidate(call.call.candidate||null).catch(err=>null),null;let id=call.id,to=call.from.toString(),pc=new RTCPeerConnection(config);if(calls[id]={id:id,pc:pc,channels:{},localTracks:[],remoteTracks:[]},stream&&localTrackAdded(stream,pc,id),pc.ondatachannel=(e=>{ChannelAdded(e,pc,id)}),pc.ontrack=(e=>{remoteTrackAdded(e,pc,id)}),!call.call.desc)return null;new RTCSessionDescription(call.call.desc||null),await pc.setRemoteDescription(call.call.desc||null),pc.createAnswer().then(async answerDesc=>{await pc.setLocalDescription(answerDesc),send({id:id,to:to.toString(),type:"answer",answer:{desc:answerDesc}}),pc.onicecandidate=(e=>{e.candidate&&send({id:id,to:to.toString(),type:"answer",answer:{candidate:e.candidate}})}),resolve(calls[id])})})},gotAnswer:async function(answer){if(!answer&&!answer.id&&!calls[answer.id]&&"answer"!==answer.type)return null;const conn=calls[answer.id];if(answer.answer&&answer.answer.candidate)return await conn.pc.addIceCandidate(answer.answer.candidate).catch(err=>null),null;const answerDesc=new RTCSessionDescription(answer.answer.desc||null);conn.pc.setRemoteDescription(answerDesc)},onState:cb=>{onState=cb}}}